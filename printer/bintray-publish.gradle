import java.nio.charset.StandardCharsets
apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'

/*
 * This Gradle file takes care of creating anything necessary to publish a library module to
 * the Bintray JCenter repository.
 *
 * Provide the following Shell environment variables:
 * BINTRAY_USER = Bintray username
 * BINTRAY_API_KEY = Bintray Api Key
 * BINTRAY_GPG_PASSWORD = Bintray GPG private key password
 * SONATYPE_USER = Sonatype username for publishing to Maven Central
 * SONATYPE_PASSWORD = Sonatype username for publishing to Maven Central
 *
 * Add the following extra properties to your project:
 * groupId = Group ID for Maven
 * artifactId = Artifact ID for Maven
 * name = Projects tend to have conversational names, beyond the artifactId.
 *      The Sun engineers did not refer to their project as "java-1.5", but rather just called it "Tiger".
 * description = Description of a project is always good. Although this should not replace
 *      formal documentation, a quick comment to any readers of the POM is always helpful.
 * url = The URL usually refers to where the project lives.
 * inceptionYear = It will help you remember where you have spent the last few years of your life.
 * scmUrl = Repository url
 * licenseName = Standard license name
 * licenseUrl = Url pointing to the text version of the license
 * developers = ArrayList containing an HashMap with the following developers information:
 *          id, name, email, organization, organizationUrl
 *
 * Version: 0.9.8
 */
checkMandatoryEnvVar('BINTRAY_USER')
checkMandatoryEnvVar('BINTRAY_API_KEY')
checkMandatoryEnvVar('BINTRAY_GPG_PASSWORD')
checkMandatoryEnvVar('SONATYPE_USER')
checkMandatoryEnvVar('SONATYPE_PASSWORD')
checkMandatoryProperty('groupId')
checkMandatoryProperty('artifactId')
checkMandatoryProperty('name')
checkMandatoryProperty('description')
checkMandatoryProperty('url')
checkMandatoryProperty('inceptionYear')
checkMandatoryProperty('scmUrl')
checkMandatoryProperty('licenseName')
checkMandatoryProperty('licenseUrl')
checkMandatoryProperty('developers')

android {
    buildTypes {
        all {
            if (!file('proguard-rules.pro').exists()) {
                throw new GradleException('You must provide a Proguard file named ' +
                        '\'proguard-rules.pro\' which contains the rules for your library, ' +
                        'otherwise the main app could crash.')
            }
            consumerProguardFiles 'proguard-rules.pro'
        }
    }
}

task sourcesJar(type: Jar, dependsOn: 'assembleRelease') {
    group BasePlugin.BUILD_GROUP
    description 'Package sources into a jar'
    classifier = 'sources'
    from android.sourceSets.main.java.sourceFiles
}

task javadoc(type: Javadoc, dependsOn: 'assembleRelease') {
    group BasePlugin.BUILD_GROUP
    description 'Generate Javadocs'
    source = android.sourceSets.main.java.sourceFiles
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    classpath += configurations.compile
    failOnError false
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    group BasePlugin.BUILD_GROUP
    description 'Package Javadocs into a jar'
    classifier = 'javadoc'
    from javadoc.destinationDir
}

publishing {
    publications {
        Production(MavenPublication) {
            groupId project.ext.get('groupId')
            artifactId project.ext.get('artifactId')
            version android.defaultConfig.versionName
            artifact("$buildDir/outputs/aar/${project.name}-release.aar")
            artifact sourcesJar
            artifact javadocJar
            pom.withXml {
                def mainNode = asNode()
                mainNode.appendNode('name', project.ext.get('name'))
                mainNode.appendNode('description', project.ext.get('description'))
                mainNode.appendNode('url', project.ext.get('url'))
                mainNode.appendNode('inceptionYear', project.ext.get('inceptionYear'))

                def scmNode = mainNode.appendNode('scm')
                scmNode.appendNode('url', project.ext.get('scmUrl'))

                def licensesNode = mainNode.appendNode('licenses')
                def licenseNode = licensesNode.appendNode('license')
                licenseNode.appendNode('name', project.ext.get('licenseName'))
                licenseNode.appendNode('url', project.ext.get('licenseUrl'))
                licenseNode.appendNode('distribution', 'repo')

                def developersNode = mainNode.appendNode('developers')
                def developers = project.ext.get('developers')
                developers.each { developer ->
                    def developerNode = developersNode.appendNode('developer')
                    developerNode.appendNode('id', developer.get('id'))
                    developerNode.appendNode('name', developer.get('name'))
                    developerNode.appendNode('email', developer.get('email'))
                    developerNode.appendNode('organization', developer.get('organization'))
                    developerNode.appendNode('organizationUrl', developer.get('organizationUrl'))
                    def rolesNode = developerNode.appendNode('roles')
                    rolesNode.appendNode('role', 'developer')
                }

                def dependenciesNode = mainNode.appendNode('dependencies')
                List<MyDependency> myDependencies
                try {
                    myDependencies = processDependencies(configurations.getByName("compile"),
                            myDependencies, false)
                } catch (UnknownConfigurationException e) {
                    // compile not supported by this Gradle version
                }
                try {
                    myDependencies = processDependencies(configurations.getByName("api"),
                            myDependencies, false)
                    myDependencies = processDependencies(configurations.getByName("implementation"),
                            myDependencies, true)
                } catch (UnknownConfigurationException e) {
                    // api/implementation not supported by this Gradle version
                }
                addPomDependencies(dependenciesNode, myDependencies)
            }
        }
    }
}

bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_API_KEY')
    publications = ['Production']
    override = true
    pkg {
        userOrg = 'stetel'
        repo = 'Android'
        name = project.ext.get('artifactId')
        description = project.ext.get('description')

        publish = true
        publicDownloadNumbers = false
        licenses = ["LGPL-3.0"]
        vcsUrl = project.ext.get('url') + '.git'
        dryRun = false
        version {
            name = android.defaultConfig.versionName
            desc = project.ext.get('description')
            released = new Date()
            vcsTag = android.defaultConfig.versionName
            gpg {
                sign = true
                passphrase = System.getenv('BINTRAY_GPG_PASSWORD')
            }
            mavenCentralSync {
                sync = true
                user = System.getenv('SONATYPE_USER')
                password = System.getenv('SONATYPE_PASSWORD')
                close = '1'
            }
        }
    }
}

void checkMandatoryProperty(String name) {
    if (!project.ext.has(name)) {
        throw new GradleException("Missing extra property '${name}'. " +
                "You should define '${name}' in the ext section of the lib gradle file.")
    }
}

void checkMandatoryEnvVar(String name) {
    String env = System.getenv(name)
    System.print("env: " + env)
    if (env == null || env.isEmpty()) {
        throw new GradleException("Missing Shell environment var '${name}'. " +
                "Check the Bash (or OS) documentation on how to export it.")
    }
}

List<MyDependency> processDependencies(Configuration configuration, List<MyDependency> myDependencies, boolean runtime) {
    if (myDependencies == null) {
        myDependencies = new ArrayList<>()
    }
    configuration.getDependencies().each { dep ->
        MyDependency foundDep = myDependencies.find { depEntry -> depEntry.isSameArtifact(dep)}
        if (foundDep == null) {
            myDependencies.add(new MyDependency(dep, runtime))
        } else if (foundDep.isVersionLower(dep)) {
            foundDep.setVersion(dep.getVersion())
        } else if (foundDep.isRuntime() && !runtime) {
            foundDep.setRuntime(false)
        }
    }
    return myDependencies
}

void addPomDependencies(dependenciesNode, List<MyDependency> myDependencies) {
    myDependencies.each { myDependency ->
        if (myDependency.isValid()) {
            def dependencyNode = dependenciesNode.appendNode('dependency')
            dependencyNode.appendNode('groupId', myDependency.getGroupId())
            dependencyNode.appendNode('artifactId', myDependency.getArtifactId())
            dependencyNode.appendNode('version', myDependency.getVersion())
            if (myDependency.isRuntime()) {
                dependencyNode.appendNode('scope', "runtime")
            }
            if (!myDependency.getExcludeRules().empty) {
                def exclusionsNode = dependencyNode.appendNode('exclusions')
                myDependency.getExcludeRules().each { ExcludeRule rule ->
                    def exclusionNode = exclusionsNode.appendNode('exclusion')
                    exclusionNode.appendNode('groupId', rule.group)
                    exclusionNode.appendNode('artifactId', rule.module)
                }
            }
        }
    }
}

class MyDependency {
    String groupId
    String artifactId
    String version
    boolean runtime
    Set<ExcludeRule> excludeRules

    MyDependency(Dependency dependency, boolean runtime) {
        this.groupId = dependency.getGroup()
        this.artifactId = dependency.getName()
        this.version = dependency.getVersion()
        this.runtime = runtime
        this.excludeRules = dependency.properties.excludeRules
    }

    boolean isValid() {
        return groupId != null && artifactId != null && artifactId != "unspecified" && version != null
    }

    boolean isSameArtifact(Dependency depToCompare) {
        return this.groupId == depToCompare.getGroup() && this.artifactId == depToCompare.getName()
    }

    boolean isVersionLower(Dependency depToCompare) {
        return VersionNumber.parse(version) < VersionNumber.parse(depToCompare.getVersion())
    }

    @Override
    String toString() {
        return "MyDependency{" +
                "groupId='" + groupId + '\'' +
                ", artifactId='" + artifactId + '\'' +
                ", version='" + version + '\'' +
                ", runtime=" + runtime +
                ", excludeRules=" + excludeRules +
                '}'
    }
}
